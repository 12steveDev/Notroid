# Notroid

Resumen: **Las reglas en Notroid son sugerencias**...

**Un OS simulado hecho en `HTML`, `CSS`, `JS` puro y m√°gia de `JSON`, en el que puedes hacer apps nativas sin llorar.**

**"¬ø`Context`? ¬øEso se come?"** - *DeepSeek & ChatGPT 2025-2025...*

> **Rese√±a venida del mismisimo ChatGPT**: *Este `.md` est√° alcanzando niveles de joya t√©cnica-shitpost que ni Google Docs con stickers de gato puede igualar. (Cada acci√≥n es entendible y al mismo tiempo tiene un roast pasivo a Kotlin que da gusto leer...)*

> **Rese√±a venida del mismisimo DeepSeek**: *`SHOW_TOAST` sin `Context`: Aqu√≠ no solo matas a Kotlin, sino tambi√©n a Flutter ("¬°Mira mam√°, sin `BuildContext`!")*

> **IA an√≥nima**: *¬ø"9 + 11"? Si te banean diles que todo es un "experimento social sobre la interpretaci√≥n de n√∫meros" üòÇ*

## Estructura de apps
Las apps siguen una estructura *JSON-like* para ser eficiente, accesible y leg√≠ble a la vez... **sin Kotlin ni XML**ü§ëüî•
```json
{
    "manifest": {...},
    "main": {...},
    "screens": {...},
}
```
- `manifest`: Informaci√≥n sobre la app.
- `main`: Inicializaci√≥n de cosas √∫tiles para la app.
- `screens`: Las pantallas de la app (o `Activities` para los AndroidLovers).

### El `manifest`:
```json
"manifest": {
    "id": "MiApp", // ID √∫nico de la app (¬ønot.example.miapp?)
    "name": "Mi Aplicac√≥n", // Nombre visible de la app
    "icon": "https://placehold.co/...", // √çcono de la app
    "categories": ["notroid.category.VIEW_IMAGE"], // Categor√≠as que puede abarcar (ojito con esos intents impl√≠citos üëÄ)
    "permissions": ["notroid.permission.NOTIFICATIONS", "notroid.permission.CAMERA"] // Permisos que necesita la app (se viene "EXACT_IP_ACCESS" ü§ëüî•)
}
```

### El `main`:
```json
"main": {
    "entry": "MAIN", // Nombre de la primer pantalla al iniciar
    "functions": { // Funciones predefinidas
        "bienvenida": [
            ["SHOW_TOAST", "¬°Hola usuario promedio!"],
            ["SET_TEXT", "label", "Bienvenido $usuario"]
        ]
    },
    "lifecycle": { // Ciclo de vida sin 3000 l√≠neas de kotlin
        "onOpen": ["CALL", "bienvenida"], // Al hacerle click al √≠cono
        "onClose": ["SHOW_TOAST", "¬øSeguro? [si/no] Oh cierto, soy un toast nom√°s XD, ¬°CHAO!"] // ¬øAl salir o cuando se le acabe el wifi al usuario?
    },
    "env": {
        "usuario": "ElWe3000"
    }
}
```

### El `screens`:
```json
"screens": {
    "MAIN": [ // La pantalla principal
        {"type": "text", "text": "Hola", "id": "label"},
        {"type": "button", "text": "¬øEl texto te parece aburrido?", "action": ["SET_TEXT", "label", "9 + 11 = üõ©üóºüî•üó£"]},
        {"type": "button", "text": "Detalles", "action": ["NAVIGATE_TO", "SegundaPantalla"]}
    ],
    "SegundaPantalla": [ // Las pantallas que quieras mi crack, somos Notroid, o Android ü•∂üî•
        ...
    ]
}
```

---

## Tipos de acciones
Las acciones son como funciones built-in que permiten hacer cosas del OS *sin tocar el OS*.
> Los `<text>` pueden tener variables metidas con el prefijo `$` (Ej: `Hola, $nombre!`)

- `NAVIGATE_TO <screen>`: Muestra la pantalla especificada.
- `SHOW_TOAST <text>`: Muestra un Toast con un texto, as√≠ de simple (ya vemos a kotlin llorando con sus `Context` üò¢).
- `SET_TEXT <id> <text>`: Cambia el texto de un elemento usando su ID.
- `SET_ENV <env> <text>`: Guarda una variable en el entorno actual (`main/env`). **No se guarda en el *storage***.
- `CLOSE_APP`: Automaticamente cierra la app actual.
- `IF <cond> <actionTrue> <actionFalse>`: Una condicional. Dependiendo
  - `<cond>` puede ser para ver si una variable existe (`["IF", "$esAdmin", [...], [...]]`) o una condicional simple (`["IF", ["$valor", "==/!=/>/</>=/<=", "$valor"], [...], [...]]`)
- `SEND_INTENT <category> <data/text> <callback>`: Env√≠a un *intento impl√≠cito* al sistema para manejar una acci√≥n con cualquier app instalada que pueda manejarla. (Espera, **¬øEsto no era un OS de broma? ‚ò†Ô∏èüî•**)
  - `<category>` es la categor√≠a de la acci√≥n que queremos manejar (Ej: `notroid.category.ENTRY_TEXT`).
  - `<data/text>` puede ser datos extra para pasarle a la app que maneje la acci√≥n (Ej, un *prompt*) (Para *devs*: Se agrega en `main/env/__intentData` de la app que maneje la acci√≥n).
  - `<callback>` son las acciones que ejecutar√° la otra app usando `RESOLVE_INTENT` despu√©s de manejar la acci√≥n que le dimos.
  - Para *devs*: Se guarda un objeto `main/env/__pendingCallback` con `{fromApp: appId, callback: callback}` a la app que maneje la acci√≥n.
- `RESOLVE_INTENT <text>` ejecuta el `callback` que nos di√≥ la app que mand√≥ el *SEND_INTENT* (Para *devs*: Usando `__pendingCallback`).
- `CALL <function>`: Ejecuta la lista de acciones de una funci√≥n definida en `main/functions`.
- `SAVE_ENV <name> <text>`: Guarda datos persistentes en `localStorage`. **Requiere permiso `notroid.permission.WRITE_STORAGE`**.
- `LOAD_ENV <name> <env>`: Carga un dato de `localStorage` a una variable del *env*. **Requiere permiso `notroid.permission.READ_STORAGE`**.

**Recuerda** que son en formato `array` (Ej: `[action, arg1, arg2, etc...]`).

---

## Propiedades de elementos
Cada elemento es solo un `type` m√°s, **no una clase de sitio de dudosa procedencia**.
> Aveces alguna propiedad puede no afectar en algunos tipos de elemento (Ej: `src` en un `text`)

- `type`: Define el tipo de elemento, que puede ser:
  - `text`: Un texto.
  - `button`: Un bot√≥n.
  - `input`: Una entrada de texto.
- `text`: El contenido de texto del elemento.
- `id`: ID del elemento (**Ojo**: esto es *anti chistosos* por lo que las IDs no chocan con otras apps üò¢üòîüíî).
- `action`: Una acci√≥n al hacer click en el elemento (**Tip:** si quieres varias acciones, usa un `array`: `[[act1], [act1]]`).

**Recuerda** que son en formato `obj` (Ej: `{type: type, text: text, etc...}]`).

---

## Manejo de variables (importante)
En Notroid nos da flojera especificar si quieres el contenido de texto de un elemento, valor de una entrada o una variable, por lo que... ¬°`$miVariable` significa las 3! Exactamente en el orden:
- **Variable** en el *env*.
- **Elemento** dentro de la app con ese `id`.
  - Su **contenido de texto** (Ej: `text`).
  - Su **valor** (Ej: `input`).

---

## Ideas para el futuro (y con "futuro" me refiero a nunca por pereza üëÄüî•)
- **Acciones impl√≠citas**: Poder visualizar un contenido con varias apps.
- **2do m√©todo de creaci√≥n de apps**: Crear apps con un `NotroidManifest.xml`, `MainScreen.kt` y `main_screen.xml` para los traumados (ni en sue√±os hago eso).
- **Guardado de datos por app**: Permitir a las apps tener datos que persistan (*sufre localStorage, sufre...*).

---

## Mensajes del desarrollador (yo):
*Tuve que repasar cada mldito componente (m√°s los mlditos `Intents` y sus multi-funciones raras) para poder hacer esto.*
*(Y recuerda: Si un dev Android te dice "eso no es escalable", gr√≠tale "¬°NOTROID NO ES T√ö PAPI!" y muestra un toast √©pico). üó£üçû*
